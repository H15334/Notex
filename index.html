<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Notex v1 - Notes App (Offline)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      // Tailwind configuration (remains the same)
      tailwind.config = {
        darkMode: 'class',
        theme: {
          extend: {
            fontFamily: {
              sans: ['Inter', 'sans-serif'],
            },
            transitionProperty: {
              'width': 'width',
              'height': 'height',
              'spacing': 'margin, padding',
            },
            keyframes: {
              'fade-in': {
                '0%': { opacity: '0' },
                '100%': { opacity: '1' },
              },
              'slide-up': {
                '0%': { transform: 'translateY(20px)', opacity: '0' },
                '100%': { transform: 'translateY(0)', opacity: '1' },
              },
              'pulse': {
                '0%, 100%': { opacity: '1' },
                '50%': { opacity: '0.5' },
              }
            },
            animation: {
              'fade-in': 'fade-in 0.3s ease-out',
              'slide-up': 'slide-up 0.3s ease-out',
              'pulse': 'pulse 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite',
            },
          },
        },
      }
    </script>
    <style>
      /* Custom Scrollbars */
      ::-webkit-scrollbar { width: 10px; height: 10px; }
      ::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
      ::-webkit-scrollbar-thumb { background: #c1c1c1; border-radius: 10px; border: 2px solid #f1f1f1; }
      ::-webkit-scrollbar-thumb:hover { background: #a8a8a8; }
      .dark ::-webkit-scrollbar-track { background: #2d3748; }
      .dark ::-webkit-scrollbar-thumb { background: #4a5568; border-color: #2d3748; }
      .dark ::-webkit-scrollbar-thumb:hover { background: #5f6b82; }

      /* Editor styling - Base styles */
      [contenteditable="true"] {
        border: 1px solid #d1d5db; /* Light border */
        border-radius: 0.5rem;
        padding: 0.75rem;
        min-height: 150px;
        outline: none;
        transition: all 0.2s ease;
        overflow-wrap: break-word;
        word-wrap: break-word;
        word-break: break-word;
        white-space: pre-wrap;
        overflow-y: auto;
        background-color: white; /* Explicit background */
      }
      .dark [contenteditable="true"] {
        border-color: #4b5563; /* Dark border */
        background-color: #374151; /* Dark background */
        color: #d1d5db;
      }
      [contenteditable="true"]:focus {
        border-color: #d1d5db;
        --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
        --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);
        box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
        --tw-ring-color: #3b82f6;
      }
      .dark [contenteditable="true"]:focus {
        border-color: #4b5563;
        --tw-ring-color: #60a5fa;
      }

      /* Format buttons */
      .format-button {
        padding: 0.3rem 0.5rem;
        border: 1px solid #d1d5db;
        border-radius: 0.375rem;
        background-color: #f3f4f6;
        color: #374151;
        transition: all 0.2s ease;
      }
      .format-button:hover { background-color: #e5e7eb; transform: translateY(-1px); }
      .format-button:active { transform: translateY(1px); }
      .format-button.active { background-color: #dbeafe; border-color: #93c5fd; color: #1e40af; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1); }
      .dark .format-button { background-color: #4b5563; color: #d1d5db; border-color: #6b7280; }
      .dark .format-button:hover { background-color: #374151; }
      .dark .format-button.active { background-color: #374151; border-color: #6b7280; color: #eff6ff; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2); }

      /* Tags */
      .tag { display: inline-block; background-color: #e0e7ff; color: #3730a3; padding: 0.25rem 0.5rem; border-radius: 9999px; font-size: 0.75rem; font-weight: 500; margin-right: 0.25rem; margin-bottom: 0.25rem; transition: all 0.2s ease; border: 1px solid #c7d2fe; }
      .tag:hover { transform: scale(1.05); background-color: #c7d2fe; }
      .dark .tag { background-color: #3730a3; color: #e0e7ff; border-color: #4338ca; }
      .dark .tag:hover { background-color: #4338ca; }

      /* Modal */
      .modal { display: none; position: fixed; z-index: 50; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5); align-items: center; justify-content: center; animation: fade-in 0.3s ease-out; }
      .modal.flex { display: flex; }
      .modal-content { margin: auto; padding: 1.5rem; border-radius: 0.5rem; width: 90%; max-width: 500px; animation: slide-up 0.3s ease-out; border: 1px solid #e5e7eb; }
      .dark .modal-content { border-color: #374151; }

      /* Toggle switch */
      .toggle-switch { position: relative; display: inline-block; width: 50px; height: 26px; }
      .toggle-switch input { display: none; }
      .toggle-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 26px; border: 1px solid #bbb; }
      .toggle-slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; box-shadow: 0 1px 2px rgba(0,0,0,0.2); }
      input:checked + .toggle-slider { background-color: #2563eb; border-color: #1d4ed8; }
      input:checked + .toggle-slider:before { transform: translateX(24px); }
      .dark .toggle-slider { background-color: #4b5563; border-color: #374151; }
      .dark input:checked + .toggle-slider { background-color: #3b82f6; border-color: #2563eb; }

      /* Clear search button */
      #clearSearchBtn { position: absolute; right: 0.5rem; top: 50%; transform: translateY(-50%); background: none; border: none; padding: 0.25rem; cursor: pointer; color: #9ca3af; display: none; transition: all 0.2s ease; }
      #clearSearchBtn:hover { color: #6b7280; transform: translateY(-50%) scale(1.1); }
      .dark #clearSearchBtn { color: #6b7280; }
      .dark #clearSearchBtn:hover { color: #9ca3af; }

      /* Selection indicators */
      .note-item.selected { background-color: #dbeafe !important; border-color: #93c5fd !important; box-shadow: 0 2px 8px rgba(59, 130, 246, 0.2); transform: translateX(4px); }
      .dark .note-item.selected { background-color: #1e3a8a !important; border-color: #3b82f6 !important; box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3); }
      .note-item { transition: all 0.3s ease; cursor: grab; }

      /* Notes list scroll container */
      #notesList { scrollbar-width: thin; scrollbar-color: #c1c1c1 #f1f1f1; }
      .dark #notesList { scrollbar-color: #4a5568 #2d3748; }

      /* --- Mobile View & Fullscreen Control --- */
      body:not(.editor-fullscreen) #sidebar { display: flex; width: 100%; }
      body:not(.editor-fullscreen) #editorArea { display: none; }
      body.editor-fullscreen #sidebar { display: none; }
      body.editor-fullscreen #editorArea { display: flex; position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 1000; padding: 1rem; background: white; width: 100%; height: 100%; max-width: none; border-radius: 0; animation: fade-in 0.3s ease-out; }
      .dark body.editor-fullscreen #editorArea { background: #1f2937; }

      /* Desktop state */
      @media (min-width: 768px) {
        body:not(.editor-fullscreen) #sidebar { display: flex; width: 33.333333%; }
        body:not(.editor-fullscreen) #editorArea {
          display: flex; position: relative; width: 66.666667%; height: auto;
          max-width: none; padding: 1.5rem; z-index: auto; border-radius: 0;
          animation: none;
          border-left: 1px solid #e5e7eb;
        }
        .dark body:not(.editor-fullscreen) #editorArea {
          background: #1f2937;
          border-left-color: #374151;
        }
        body.editor-fullscreen #sidebar { display: none; }
        body.editor-fullscreen #editorArea {
          display: flex; position: fixed; top: 0; left: 0; right: 0; bottom: 0;
          z-index: 1000; padding: 1rem; background: white; width: 100%; height: 100%;
          max-width: none; border-radius: 0; animation: fade-in 0.3s ease-out;
          border-left: none;
        }
         .dark body.editor-fullscreen #editorArea {
            background: #1f2937; border-left: none;
         }
      }

      /* --- Styles for Editor Content within Fullscreen --- */
      body.editor-fullscreen #noteEditor { height: 100%; display: flex; flex-direction: column; width: 100%; margin: 0 auto; padding: 0; }
      body.editor-fullscreen #noteContent { flex-grow: 1; min-height: auto; font-size: 1.1rem; line-height: 1.6; }
      body.editor-fullscreen #noteTitle { font-size: 1.8rem; padding: 0.5rem 0.75rem; margin-bottom: 1rem; text-align: center; }
      body.editor-fullscreen #editorHeader { margin-bottom: 1rem; padding: 0; }
      body:not(.editor-fullscreen) #backBtn { display: none !important; }
      body.editor-fullscreen #backBtn { display: flex !important; }

      /* --- Styles for Editor Content in Regular View --- */
       body:not(.editor-fullscreen) #noteContent { font-size: inherit; line-height: inherit; }
       .dark body:not(.editor-fullscreen) #noteContent { }
       body:not(.editor-fullscreen) #noteTitle { font-size: 1.5rem; padding: 0.75rem; margin-bottom: 1rem; text-align: left; }
       .dark body:not(.editor-fullscreen) #noteTitle { }

       /* --- Drag and Drop Styling --- */
       .note-item.dragging { opacity: 0.5; background-color: #e0f2fe; border: 1px dashed #0ea5e9; cursor: grabbing; }
       .dark .note-item.dragging { background-color: #0c4a6e; border-color: #38bdf8; }
       .drag-over { border-top: 2px solid #3b82f6 !important; transition: border-top 0.1s ease-in-out; }
       .note-item.dragging.drag-over { border-top: none !important; }

    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100 dark:bg-gray-900 font-sans flex flex-col h-screen transition-colors duration-300">

    <header class="bg-blue-600 dark:bg-blue-800 text-white p-4 shadow-md flex justify-between items-center transition-all duration-300 z-10">
        <h1 class="text-2xl font-bold animate-slide-up">My Notes</h1>
        <button id="settingsBtn" title="Settings" class="text-white hover:text-blue-200 p-2 rounded-full hover:bg-blue-700 dark:hover:bg-blue-900 transition-all duration-300 hover:rotate-45 border border-transparent hover:border-blue-300">
            ‚öôÔ∏è
        </button>
    </header>

    <div class="flex flex-1 overflow-hidden transition-all duration-300">
        <aside id="sidebar" class="bg-white dark:bg-gray-800 border-r border-gray-200 dark:border-gray-700 flex flex-col transition-all duration-300">
            <div class="p-4 border-b border-gray-200 dark:border-gray-700 space-y-3 animate-fade-in">
                <div class="relative">
                    <input type="search" id="searchInput" placeholder="Search notes..." class="w-full p-2 pl-8 pr-10 border border-gray-300 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 placeholder-gray-400 dark:placeholder-gray-500 transition-all duration-300">
                    <span class="absolute left-2 top-1/2 transform -translate-y-1/2 text-gray-400 dark:text-gray-500 pointer-events-none transition-all duration-300">üîç</span>
                    <button id="clearSearchBtn" title="Clear search" class="transition-all duration-300">‚ùå</button>
                </div>
                <button id="newNoteBtn" class="w-full bg-blue-500 hover:bg-blue-600 dark:bg-blue-600 dark:hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-lg flex items-center justify-center transition-all duration-300 hover:scale-105 active:scale-95 border border-blue-600 dark:border-blue-700">
                    ‚ûï New Note
                </button>
            </div>
            <div id="notesList" class="flex-1 overflow-y-auto p-2 space-y-1 animate-fade-in">
                </div>
        </aside>

        <main id="editorArea" class="flex-1 bg-gray-50 dark:bg-gray-900 p-6 flex flex-col relative transition-all duration-300">
            <div id="noteEditor" class="flex flex-col h-full hidden animate-fade-in">
                <div id="editorHeader" class="flex justify-between items-center mb-4 transition-all duration-300">
                    <button id="backBtn" title="Back to Notes" class="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 p-2 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-700 transition-all duration-300 hover:scale-105 active:scale-95 flex items-center gap-2 border border-transparent hover:border-gray-300 dark:hover:border-gray-600">
                        ‚¨ÖÔ∏è <span class="hidden sm:inline">Back</span>
                    </button>
                    <button id="deleteNoteBtn" title="Delete Note" class="text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-500 p-2 rounded-lg hover:bg-red-100 dark:hover:bg-gray-700 transition-all duration-300 hover:scale-105 active:scale-95 flex items-center gap-2 border border-transparent hover:border-red-300 dark:hover:border-red-500">
                        üóëÔ∏è <span class="hidden sm:inline">Delete</span>
                    </button>
                </div>

                <input type="text" id="noteTitle" placeholder="Note Title" class="text-2xl font-semibold p-3 mb-4 border border-gray-300 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 placeholder-gray-400 dark:placeholder-gray-500 transition-all duration-300">

                <div class="flex space-x-2 mb-2 p-2 bg-gray-100 dark:bg-gray-700 rounded-md border border-gray-200 dark:border-gray-600 transition-all duration-300">
                    <button class="format-button" data-command="bold" title="Bold">B</button>
                    <button class="format-button" data-command="italic" title="Italic">I</button>
                    <button class="format-button" data-command="underline" title="Underline">U</button>
                    </div>

                <div id="noteContent" contenteditable="true" class="flex-1 text-gray-900 dark:text-gray-100 transition-all duration-300 overflow-auto"></div>

                <div class="mt-4 transition-all duration-300 border border-gray-200 dark:border-gray-600 rounded-lg p-3 bg-white dark:bg-gray-700">
                    <label for="noteTags" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                        üè∑Ô∏è Tags (comma-separated)
                    </label>
                    <input type="text" id="noteTags" placeholder="e.g., work, ideas, important" class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 placeholder-gray-400 dark:placeholder-gray-500 transition-all duration-300">
                    <div id="tagsPreview" class="mt-2 flex flex-wrap transition-all duration-300">
                        </div>
                </div>
            </div>
            <div id="noNoteSelected" class="flex-1 flex items-center justify-center text-gray-500 dark:text-gray-400 text-center hidden">
                <p>Select a note from the list or create a new one.</p>
            </div>
        </main>
    </div>

    <div id="settingsModal" class="modal bg-black/50 dark:bg-black/70">
        <div class="modal-content bg-white dark:bg-gray-800 shadow-xl text-gray-900 dark:text-gray-100 border border-gray-300 dark:border-gray-600">
            <div class="flex justify-between items-center border-b border-gray-200 dark:border-gray-700 pb-3 mb-4">
                <h2 class="text-xl font-semibold">Settings</h2>
                <button id="closeSettingsBtn" class="text-gray-500 hover:text-gray-800 dark:text-gray-400 dark:hover:text-white transition-all duration-300 hover:rotate-90 p-1 rounded-md border border-transparent hover:border-gray-300 dark:hover:border-gray-600">
                    ‚ùå
                </button>
            </div>
            <div class="space-y-4">
                <div class="flex justify-between items-center">
                    <label for="darkModeToggle" class="font-medium flex items-center gap-2">
                        <span id="themeIcon">üåô</span> Dark Mode
                    </label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="darkModeToggle">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <hr class="border-gray-200 dark:border-gray-600 my-4">
                <div class="text-center text-sm text-gray-500 dark:text-gray-400 space-y-1">
                    <p>Notex version 1 (Offline Enabled)</p>
                    <p>Created by Himanshu pal</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const notesListEl = document.getElementById('notesList');
        const searchInput = document.getElementById('searchInput');
        const clearSearchBtn = document.getElementById('clearSearchBtn');
        const newNoteBtn = document.getElementById('newNoteBtn');
        const noteEditorEl = document.getElementById('noteEditor');
        const noteTitleInput = document.getElementById('noteTitle');
        const noteContentInput = document.getElementById('noteContent');
        const noteTagsInput = document.getElementById('noteTags');
        const tagsPreviewEl = document.getElementById('tagsPreview');
        const deleteNoteBtn = document.getElementById('deleteNoteBtn');
        const editorAreaEl = document.getElementById('editorArea');
        const settingsBtn = document.getElementById('settingsBtn');
        const settingsModal = document.getElementById('settingsModal');
        const closeSettingsBtn = document.getElementById('closeSettingsBtn');
        const darkModeToggle = document.getElementById('darkModeToggle');
        const themeIcon = document.getElementById('themeIcon');
        const formatButtons = document.querySelectorAll('.format-button');
        const backBtn = document.getElementById('backBtn');
        const sidebarEl = document.getElementById('sidebar');
        const bodyEl = document.body;
        const noNoteSelectedEl = document.getElementById('noNoteSelected'); // Get the placeholder element

        // --- State Variables ---
        let notes = [];
        let selectedNoteId = null;
        let isFullscreen = false;
        let settings = { darkMode: false };
        let debounceTimer;
        let draggedItemId = null;

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            loadSettings();
            applySettings();
            loadNotes();
            renderNotesList();
            setupEventListeners();
            checkInitialState(); // Check initial state after loading notes
            registerServiceWorker(); // Register the service worker
        });

        // --- Service Worker Registration ---
        function registerServiceWorker() {
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('sw.js') // Path to your service worker file
                    .then(registration => {
                        console.log('Service Worker registered with scope:', registration.scope);
                    })
                    .catch(error => {
                        console.error('Service Worker registration failed:', error);
                    });
            } else {
                console.log('Service Worker not supported in this browser.');
            }
        }


        // --- Settings Management ---
        function loadSettings() {
            const savedSettings = localStorage.getItem('notesAppSettings');
            if (savedSettings) { settings = JSON.parse(savedSettings); }
            darkModeToggle.checked = settings.darkMode;
        }
        function saveSettings() { localStorage.setItem('notesAppSettings', JSON.stringify(settings)); }
        function applySettings() {
            if (settings.darkMode) {
                document.documentElement.classList.add('dark');
                themeIcon.textContent = '‚òÄÔ∏è';
            } else {
                document.documentElement.classList.remove('dark');
                themeIcon.textContent = 'üåô';
            }
        }

        // --- Notes Management ---
        function loadNotes() {
            const savedNotes = localStorage.getItem('notesAppNotes');
            if (savedNotes) {
                notes = JSON.parse(savedNotes);
                // Sort notes by lastModified descending (most recent first)
                notes.sort((a, b) => b.lastModified - a.lastModified);
            } else {
                // Initialize with example notes if none exist
                notes = [
                    { id: Date.now() + 1, title: "Welcome Note", content: "<div>Start typing your notes here! Use the buttons for basic formatting. Drag notes in the sidebar to reorder. This app now works offline!</div>", tags: ["welcome", "getting started", "offline"], lastModified: Date.now() },
                    { id: Date.now() + 2, title: "Shopping List", content: "<div>- Milk</div><div>- Bread</div><div>- Eggs</div>", tags: ["personal", "todo"], lastModified: Date.now() - 86400000 } // Example: 1 day old
                ];
                saveNotes(); // Save the initial notes
            }
        }
        function saveNotes() {
            // Ensure notes are sorted before saving
            notes.sort((a, b) => b.lastModified - a.lastModified);
            localStorage.setItem('notesAppNotes', JSON.stringify(notes));
        }
        function createNewNote() {
            saveCurrentNote(); // Save any changes to the currently open note first
            const newNote = {
                id: Date.now(),
                title: "Untitled Note",
                content: "<div></div>", // Start with an empty div for consistent structure
                tags: [],
                lastModified: Date.now()
            };
            notes.unshift(newNote); // Add to the beginning of the array
            saveNotes(); // Save immediately
            renderNotesList(); // Update the list
            displayNote(newNote.id); // Display the new note
            noteTitleInput.focus(); // Focus the title input
            noteTitleInput.select(); // Select the default title
            enterFullscreen(); // Go to editor view on mobile/fullscreen
        }

        function deleteNote(id) {
            console.log("Attempting to delete note:", id);
            const deletedNoteIndex = notes.findIndex(note => note.id === id);
            if (deletedNoteIndex === -1) {
                console.warn("Note not found for deletion:", id);
                return; // Exit if note not found
            }

            notes = notes.filter(note => note.id !== id); // Remove the note
            saveNotes(); // Save the updated notes array
            renderNotesList(); // Re-render the list

            // Logic to select the next note or show placeholder
            if (selectedNoteId === id) { // If the deleted note was the one being viewed
                console.log("Deleted note was the selected one. Selecting next.");
                let nextNoteToSelect = null;
                if (notes.length > 0) {
                    // Try to select the note that was previously at the same index,
                    // or the last one if the deleted note was the last.
                    const nextIndex = Math.min(deletedNoteIndex, notes.length - 1);
                    nextNoteToSelect = notes[nextIndex];
                    console.log("Next note to select:", nextNoteToSelect ? nextNoteToSelect.id : 'None');
                } else {
                    console.log("No notes left after deletion.");
                }

                if (nextNoteToSelect) {
                    displayNote(nextNoteToSelect.id); // Display the next note
                } else {
                    displayNote(null); // No notes left, display placeholder
                }
            } else {
                console.log("Deleted note was not the selected one.");
                // No need to change the displayed note if a different one was deleted
            }
        }


        // --- Rendering ---
        function renderNotesList() {
            notesListEl.innerHTML = ''; // Clear the current list
            const searchTerm = searchInput.value.toLowerCase().trim();

            // Filter notes based on search term (title, content text, tags)
            const filteredNotes = notes.filter(note => {
                const contentText = document.createElement('div');
                contentText.innerHTML = note.content || ''; // Handle potentially null/undefined content
                return (
                    note.title.toLowerCase().includes(searchTerm) ||
                    contentText.textContent.toLowerCase().includes(searchTerm) ||
                    note.tags.some(tag => tag.toLowerCase().includes(searchTerm))
                );
            });

            // Display messages if no notes match or no notes exist
             if (filteredNotes.length === 0 && searchTerm) {
                 notesListEl.innerHTML = '<p class="text-center text-gray-500 dark:text-gray-400 p-4">No notes match your search.</p>';
                 return;
             } else if (notes.length === 0) {
                 notesListEl.innerHTML = '<p class="text-center text-gray-500 dark:text-gray-400 p-4">No notes yet. Create one!</p>';
                 return;
             }

            // Determine which notes to render (filtered or all)
            const notesToRender = searchTerm ? filteredNotes : notes;

            // Create and append list items for each note
            notesToRender.forEach(note => {
                const noteItem = document.createElement('div');
                noteItem.classList.add('note-item', 'p-3', 'border-b', 'border-gray-200', 'dark:border-gray-700', 'hover:bg-gray-100', 'dark:hover:bg-gray-700', 'rounded-md', 'transition-all', 'duration-200', 'relative'); // Added relative for potential future elements
                noteItem.dataset.id = note.id;
                noteItem.draggable = true; // Make item draggable

                // Highlight the selected note
                if (note.id === selectedNoteId) {
                    noteItem.classList.add('selected');
                }

                // Note Title
                const title = document.createElement('h3');
                title.classList.add('font-semibold', 'text-gray-800', 'dark:text-gray-100', 'truncate', 'pointer-events-none', 'mb-1'); // Added margin-bottom
                title.textContent = note.title || "Untitled Note"; // Default title

                // Note Content Preview
                const preview = document.createElement('p');
                preview.classList.add('text-sm', 'text-gray-600', 'dark:text-gray-300', 'truncate', 'pointer-events-none', 'mb-1'); // Added margin-bottom
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = note.content || ''; // Handle empty content safely
                const previewText = tempDiv.textContent.trim();
                preview.textContent = previewText.substring(0, 60) + (previewText.length > 60 ? '...' : ''); // Slightly longer preview

                // Last Modified Date
                const date = document.createElement('p');
                date.classList.add('text-xs', 'text-gray-500', 'dark:text-gray-400', 'pointer-events-none');
                date.textContent = `Modified: ${new Date(note.lastModified).toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' })}`;


                noteItem.appendChild(title);
                noteItem.appendChild(preview);
                noteItem.appendChild(date);

                // Click event to select and display the note
                noteItem.addEventListener('click', () => {
                    if (noteItem.classList.contains('dragging')) return; // Don't select if dragging
                    saveCurrentNote(); // Save current note before switching
                    displayNote(note.id);
                    enterFullscreen(); // Switch to editor view on mobile/fullscreen
                });

                notesListEl.appendChild(noteItem);
            });
        }
        function displayNote(id) {
            selectedNoteId = id; // Update the globally selected ID
            const note = notes.find(n => n.id === id);

            if (note) {
                // Show editor, hide placeholder
                noteEditorEl.classList.remove('hidden');
                noNoteSelectedEl.classList.add('hidden');

                // Populate editor fields
                noteTitleInput.value = note.title;
                noteContentInput.innerHTML = note.content || ''; // Ensure content is at least an empty string
                noteTagsInput.value = note.tags.join(', ');
                renderTagsPreview(note.tags);
                updateFormatButtonStates(); // Update bold/italic/underline button states

            } else {
                // No note selected (or note not found), hide editor, show placeholder
                selectedNoteId = null;
                noteEditorEl.classList.add('hidden');
                noNoteSelectedEl.classList.remove('hidden'); // Show the placeholder message
                noNoteSelectedEl.classList.add('flex'); // Ensure it's displayed correctly

                // Clear editor fields (optional, but good practice)
                noteTitleInput.value = '';
                noteContentInput.innerHTML = '';
                noteTagsInput.value = '';
                renderTagsPreview([]);

                exitFullscreen(); // Exit fullscreen if no note is selected
            }
            renderNotesList(); // Re-render the list to update the 'selected' state visually
        }
        function renderTagsPreview(tags) {
            tagsPreviewEl.innerHTML = ''; // Clear previous tags
            tags.forEach(tag => {
                if (tag) { // Ensure tag is not empty
                    const tagEl = document.createElement('span');
                    tagEl.classList.add('tag'); // Use the defined CSS class for tags
                    tagEl.textContent = tag;
                    tagsPreviewEl.appendChild(tagEl);
                }
            });
        }

        // --- Saving and Debouncing ---
        function handleNoteChange() {
            clearTimeout(debounceTimer); // Clear existing timer
            // Set a new timer to save after a short delay (e.g., 500ms)
            debounceTimer = setTimeout(() => {
                const changed = saveCurrentNote(); // Save the note content
                if (changed) {
                     // If changes were made, update lastModified and re-render list
                     const note = notes.find(n => n.id === selectedNoteId);
                     if(note) {
                        note.lastModified = Date.now(); // Update timestamp
                        saveNotes(); // Save all notes (including the updated timestamp and order)
                        renderNotesList(); // Re-render the list to show updated date/order
                     }
                }
            }, 500); // Adjust debounce delay as needed
        }
        function saveCurrentNote() {
             if (!selectedNoteId) return false; // No note selected, nothing to save
             const note = notes.find(n => n.id === selectedNoteId);
             let changed = false; // Flag to track if any changes occurred

             if (note) {
                 // Get current values from the editor fields
                 const newTitle = noteTitleInput.value.trim(); // Trim whitespace
                 const newContent = noteContentInput.innerHTML; // Get HTML content
                 // Process tags: split by comma, trim whitespace, filter out empty strings
                 const newTags = noteTagsInput.value.split(',')
                                     .map(t => t.trim())
                                     .filter(t => t !== '');

                 // Compare with stored values and update if different
                 if (note.title !== newTitle) {
                     note.title = newTitle;
                     changed = true;
                     console.log(`Note ${note.id}: Title changed`);
                 }
                 if (note.content !== newContent) {
                     note.content = newContent;
                     changed = true;
                     console.log(`Note ${note.id}: Content changed`);
                 }
                 // Compare tags array (convert to JSON for simple comparison)
                 if (JSON.stringify(note.tags) !== JSON.stringify(newTags)) {
                     note.tags = newTags;
                     changed = true;
                     console.log(`Note ${note.id}: Tags changed`);
                 }

                 if(changed) {
                    console.log("Changes detected and saved for note:", note.id);
                    // Note: saveNotes() is called in handleNoteChange after this returns true
                 }
             }
             return changed; // Return whether changes were made
        }

        // --- Fullscreen Mode Logic (Mobile Focus) ---
        function enterFullscreen() {
            // Only enter fullscreen if not already in it AND screen is 'mobile' size
            const isMobile = window.innerWidth < 768; // md breakpoint from Tailwind
            if (isMobile && !bodyEl.classList.contains('editor-fullscreen')) {
                bodyEl.classList.add('editor-fullscreen');
                isFullscreen = true;
                console.log("Entered fullscreen editor view");
                window.dispatchEvent(new Event('resize')); // Trigger resize event if needed by layout
            } else if (!isMobile) {
                 console.log("Desktop view: Not entering fullscreen mode.");
            }
        }
        function exitFullscreen() {
            if (bodyEl.classList.contains('editor-fullscreen')) {
                // Save note before exiting fullscreen (important!)
                 handleNoteChange(); // This will trigger saveCurrentNote via debounce
                 // Use a small timeout to ensure save completes before class change affects layout/focus
                 setTimeout(() => {
                    bodyEl.classList.remove('editor-fullscreen');
                    isFullscreen = false;
                    console.log("Exited fullscreen editor view");
                    window.dispatchEvent(new Event('resize')); // Trigger resize event
                 }, 100); // Short delay
            }
        }


        // --- Formatting ---
        function applyFormat(command) {
            // Execute the formatting command (e.g., 'bold', 'italic')
            document.execCommand(command, false, null);
            noteContentInput.focus(); // Keep focus in the editor
            updateFormatButtonStates(); // Update button appearance
            handleNoteChange(); // Trigger save since content changed
        }
        function updateFormatButtonStates() {
             // Check the state of each format command and update button styles
             formatButtons.forEach(button => {
                 const command = button.dataset.command;
                 // Ensure the command is supported and the editor has focus
                 if (document.queryCommandSupported(command) && document.activeElement === noteContentInput) {
                     try {
                         // Check if the command is currently active at the cursor position
                         if (document.queryCommandState(command)) {
                             button.classList.add('active'); // Add 'active' class
                         } else {
                             button.classList.remove('active'); // Remove 'active' class
                         }
                     } catch (e) {
                         // Log errors if queryCommandState fails (can happen in some edge cases)
                         console.error("Error checking command state:", command, e);
                         button.classList.remove('active');
                     }
                 } else {
                      // Remove 'active' class if editor not focused or command not supported
                      button.classList.remove('active');
                 }
             });
        }

        // --- Drag and Drop Handlers ---
        function handleDragStart(e) {
            // Only allow dragging on actual note items
            if (e.target.classList.contains('note-item')) {
                draggedItemId = e.target.dataset.id; // Store the ID of the dragged item
                e.dataTransfer.effectAllowed = 'move'; // Indicate the type of drag operation
                // Add visual feedback class after a tiny delay to ensure it's applied
                setTimeout(() => e.target.classList.add('dragging'), 0);
                console.log("Drag Start:", draggedItemId);
            } else {
                e.preventDefault(); // Prevent dragging other elements within the list
            }
        }
        function handleDragOver(e) {
            e.preventDefault(); // Necessary to allow dropping
            e.dataTransfer.dropEffect = 'move'; // Indicate this is a valid drop target

            const targetItem = e.target.closest('.note-item'); // Find the note item being hovered over
            const list = notesListEl;

            // Clear previous drag-over indicators
            list.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));

            // Add indicator to the target item if it's a valid drop target (not the item being dragged)
            if (targetItem && targetItem.dataset.id !== draggedItemId) {
                 // Determine if dragging over top or bottom half (optional, for more precise indicator)
                 // const rect = targetItem.getBoundingClientRect();
                 // const isOverTopHalf = e.clientY < rect.top + rect.height / 2;
                 // Add class based on position, e.g., 'drag-over-top' or 'drag-over-bottom'
                 // For simplicity, just adding 'drag-over' for a top border indicator
                 targetItem.classList.add('drag-over');
            }
        }
        function handleDrop(e) {
            e.preventDefault(); // Prevent default drop behavior (like opening links)
            const targetItem = e.target.closest('.note-item');
            const droppedOnId = targetItem ? targetItem.dataset.id : null; // Get ID of the item dropped onto

            // Clear visual indicators
            notesListEl.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));

            console.log("Drop:", draggedItemId, "onto", droppedOnId);

            // Perform the reorder if a valid drop occurred
            if (draggedItemId && droppedOnId && draggedItemId !== droppedOnId) {
                const draggedIndex = notes.findIndex(note => note.id == draggedItemId);
                let targetIndex = notes.findIndex(note => note.id == droppedOnId);

                if (draggedIndex !== -1 && targetIndex !== -1) {
                    // Remove the dragged note from its original position
                    const [draggedNote] = notes.splice(draggedIndex, 1);

                    // Adjust target index if the dragged item was removed from before the target
                    // This calculation might need adjustment based on how splice affects indices.
                    // Re-finding the target index after splice is safer:
                    targetIndex = notes.findIndex(note => note.id == droppedOnId);
                    if (targetIndex === -1) { // Should not happen if logic is correct
                         console.error("Target index not found after splice");
                         // Put the note back at the end as a fallback
                         notes.push(draggedNote);
                    } else {
                         // Insert the dragged note at the target index
                         notes.splice(targetIndex, 0, draggedNote);
                    }


                    saveNotes(); // Save the new order
                    renderNotesList(); // Re-render the list with the new order
                    console.log("Notes reordered and saved.");
                } else {
                     console.warn("Drag/Drop failed: Index not found.", draggedIndex, targetIndex);
                }
            } else if (draggedItemId && !droppedOnId) {
                 // Handle dropping onto the list but not on a specific item (e.g., drop at the end)
                 // Optional: Implement logic to move to the end if dropped in empty space
                 console.log("Dropped in empty space - no reorder.");
            }

            handleDragEnd(); // Clean up drag state
        }
        function handleDragEnd() {
            // Use setTimeout to ensure cleanup happens after drop event processing
            setTimeout(() => {
                const draggingItem = notesListEl.querySelector('.dragging');
                if (draggingItem) {
                    draggingItem.classList.remove('dragging'); // Remove visual feedback
                }
                // Ensure all drag-over indicators are removed
                notesListEl.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
                draggedItemId = null; // Reset the dragged item ID
                console.log("Drag End");
            }, 0);
        }


        // --- Event Listeners Setup ---
        function setupEventListeners() {
            // New Note Button
            newNoteBtn.addEventListener('click', createNewNote);

            // Search Input & Clear Button
            searchInput.addEventListener('input', () => {
                renderNotesList(); // Filter list as user types
                clearSearchBtn.style.display = searchInput.value ? 'inline-block' : 'none'; // Show/hide clear button
            });
            clearSearchBtn.addEventListener('click', () => {
                searchInput.value = ''; // Clear input
                clearSearchBtn.style.display = 'none'; // Hide button
                renderNotesList(); // Render full list
                searchInput.focus(); // Keep focus on search
            });

            // Editor Inputs (Title, Content, Tags) - Trigger save on change
            noteTitleInput.addEventListener('input', handleNoteChange);
            noteContentInput.addEventListener('input', handleNoteChange);
            noteTagsInput.addEventListener('input', () => {
                // Update tags preview immediately as user types
                const tags = noteTagsInput.value.split(',').map(t => t.trim()).filter(t => t !== '');
                renderTagsPreview(tags);
                handleNoteChange(); // Trigger save for tag changes
            });

            // Update format button states on editor interaction
            noteContentInput.addEventListener('keyup', updateFormatButtonStates);
            noteContentInput.addEventListener('mouseup', updateFormatButtonStates); // Selection change
            noteContentInput.addEventListener('focus', updateFormatButtonStates);
            noteContentInput.addEventListener('blur', () => {
                 // Save note on blur (losing focus)
                 handleNoteChange();
                 // Delay updating button states slightly on blur
                 setTimeout(updateFormatButtonStates, 100);
            });

            // Delete Note Button
            deleteNoteBtn.addEventListener('click', () => {
                if (selectedNoteId) {
                    // Confirmation dialog
                    if (confirm(`Are you sure you want to delete "${notes.find(n=>n.id===selectedNoteId)?.title || 'this note'}"?`)) {
                        deleteNote(selectedNoteId);
                    }
                } else {
                    // Should ideally not be possible if button is only visible when note selected
                    alert("No note selected to delete.");
                }
            });

            // Format Buttons
            formatButtons.forEach(button => {
                button.addEventListener('click', (e) => {
                    e.preventDefault(); // Prevent button click from taking focus away from editor
                    applyFormat(button.dataset.command);
                });
            });

            // Settings Modal
            settingsBtn.addEventListener('click', () => settingsModal.classList.add('flex'));
            closeSettingsBtn.addEventListener('click', () => settingsModal.classList.remove('flex'));
            settingsModal.addEventListener('click', (e) => {
                // Close modal if clicking on the background overlay
                if (e.target === settingsModal) {
                    settingsModal.classList.remove('flex');
                }
            });
            darkModeToggle.addEventListener('change', () => {
                settings.darkMode = darkModeToggle.checked;
                applySettings(); // Apply theme immediately
                saveSettings(); // Save preference
            });

            // Back Button (Mobile/Fullscreen)
            backBtn.addEventListener('click', exitFullscreen);

            // Escape Key to Exit Fullscreen
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && bodyEl.classList.contains('editor-fullscreen')) {
                    exitFullscreen();
                }
            });

            // Save note before page unload (important fallback)
            window.addEventListener('beforeunload', () => {
                 clearTimeout(debounceTimer); // Clear any pending saves
                 // Perform immediate save if a note is selected
                 const changed = saveCurrentNote();
                 if (changed) {
                     // Optionally update lastModified one last time
                     const note = notes.find(n => n.id === selectedNoteId);
                     if(note) note.lastModified = Date.now();
                     // Save synchronously (localStorage is synchronous)
                     saveNotes();
                     console.log("Saved note on beforeunload");
                 }
            });

            // Save on blur for title and tags as well (redundant but safe)
            noteTitleInput.addEventListener('blur', handleNoteChange);
            noteTagsInput.addEventListener('blur', handleNoteChange);

            // Drag and Drop Listeners for the Notes List
            notesListEl.addEventListener('dragstart', handleDragStart);
            notesListEl.addEventListener('dragover', handleDragOver);
            notesListEl.addEventListener('drop', handleDrop);
            notesListEl.addEventListener('dragend', handleDragEnd);
            // Prevent default drag/drop behavior on the body to avoid conflicts
            document.body.addEventListener('dragover', e => e.preventDefault());
            document.body.addEventListener('drop', e => e.preventDefault());
        }

        // --- Utility Functions ---
        function checkInitialState() {
            // Display the first note if available, otherwise show the placeholder
            if (notes.length > 0) {
                displayNote(notes[0].id); // Display the most recently modified note
            } else {
                 displayNote(null); // Display the placeholder message
            }
            // Ensure the correct view (fullscreen or side-by-side) is set based on screen size
            const isMobile = window.innerWidth < 768;
            if (!isMobile && bodyEl.classList.contains('editor-fullscreen')) {
                 // If on desktop but somehow stuck in fullscreen, exit it
                 exitFullscreen();
            } else if (isMobile && selectedNoteId && !bodyEl.classList.contains('editor-fullscreen')) {
                 // If on mobile with a note selected, ensure fullscreen mode is active
                 // enterFullscreen(); // Decided against forcing fullscreen on initial load
            }
        }

    </script>
</body>
</html>
